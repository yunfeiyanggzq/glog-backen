package main

import (
	"crypto/md5"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/noot/ring-go/cryptography"
	util "github.com/noot/ring-go/utils"
	"github.com/noot/ring-go/vote"
	"github.com/tidwall/gjson"
	"io"
	mathRand "math/rand"
	"os"
	"os/exec"
	"strings"
	"sync"
	"time"
)

const verifyFilePlacePrefix = "/Users/bytedance/code/ring-go/verifyFilePlace"
const saveFilePlace = "/Users/bytedance/code/ring-go/saveFilePlace"
const ciNum = 3
const ensureWaitSecond = 120
const caliWaitSecond = 120
const finishWaitSecond = 120

func generateMinerMock() error {
	for i := 0; i < 100; i++ {
		user := &vote.User{}
		sk, err := crypto.GenerateKey()
		if err != nil {
			return err
		}
		user.Name = fmt.Sprintf("miner%d", i)
		user.WalletSk = sk
		user.Address = util.GetMD5(sk.X.Bytes())
		user.Balance = 100
		vote.VerifyMiner[user.Name] = user
	}
	return nil
}

func generateUserMock() error {
	for i := 0; i < 1000; i++ {
		user := &vote.User{}
		sk, err := crypto.GenerateKey()
		if err != nil {
			return err
		}
		user.Name = fmt.Sprintf("user%d", i)
		user.Email = fmt.Sprintf("user%d@qq.com", i)
		user.Phone = "18811228731"
		user.Image = "default"
		user.Introduction = "Hi everyone! I am the user generated by system. please be happy every day!"
		user.LoginPassword = fmt.Sprintf("user%d", i)
		user.WalletSk = sk
		user.Address = util.GetMD5(sk.X.Bytes())
		user.Balance = 10
		user.TokenDay = 100
		user.Reputation = 10
		vote.UserMap[user.Name] = user
	}
	return nil
}

func randomChooseMiner() (users []*vote.User) {
	for i := 0; i < 3; i++ {
		users = append(users, vote.VerifyMiner[fmt.Sprintf("miner%d", mathRand.Intn(100))])
	}
	return users
}

func randomChooseUser() (users []*vote.User) {
	for i := 0; i < 10; i++ {
		users = append(users, vote.UserMap[fmt.Sprintf("user%d", mathRand.Intn(1000))])
	}
	return users
}

func generateVoter(user *vote.User, topic *vote.Topic) error {
	voter := &vote.Voter{
		Name: user.Name,
	}
	if _, ok := topic.VoterAddressMap[&user.WalletSk.PublicKey]; !ok {
		return fmt.Errorf("该用户没有被选中参与投票")
	}
	voter.WalletSk = user.WalletSk
	voterSk, err := voter.GenKey()
	if err != nil {
		return err
	}
	voter.VoterSk = voterSk
	votePublicKeyBytes := crypto.FromECDSAPub(&voter.VoterSk.PublicKey)
	signature, err := cryptography.EcdsaSign(rand.Reader, voter.WalletSk, votePublicKeyBytes)
	if err != nil {
		return err
	}

	index, err := topic.Add2VoterPublicKeyList(&voter.WalletSk.PublicKey, signature, votePublicKeyBytes)
	if err != nil {
		return err
	}
	voter.Index = index
	user.Voter = voter
	return nil
}

// 获取文件的md5码
func getFileMd5(verifyFilePlace string, filename string) string {
	// 文件全路径名
	path := fmt.Sprintf("%s/%s/%s", verifyFilePlace, filename, filename)
	pFile, err := os.Open(path)
	if err != nil {
		_ = fmt.Errorf("打开文件失败，filename=%v, err=%v", filename, err)
		return ""
	}
	defer pFile.Close()
	md5h := md5.New()
	_, _ = io.Copy(md5h, pFile)

	return hex.EncodeToString(md5h.Sum(nil))
}

func doRunCi(userName string, fileName string) (string, error) {
	verifyFilePlace := fmt.Sprintf("%s/%s", verifyFilePlacePrefix, userName)
	unzipFile := fmt.Sprintf("%s/%s.zip", saveFilePlace, fileName)
	cmd := exec.Command("/bin/sh", "./unzip.sh", unzipFile, verifyFilePlace)
	bytes, err := cmd.Output()
	if err != nil {
		fmt.Println("cmd.Output:", err)
		return "", err
	}
	md5Val := getFileMd5(verifyFilePlace, fileName)
	cmd = exec.Command("/bin/sh", "./check.sh", fmt.Sprintf("%s/%s", verifyFilePlace, fileName), fileName, fmt.Sprintf("MD5 (%s) = %s", fileName, md5Val))
	bytes, err = cmd.Output()
	if err != nil {
		fmt.Println("cmd.Output:", err)
		return "", err
	}
	return string(bytes), nil
}

func verifyFile(file *vote.File, user *vote.User, voteWaiter *sync.WaitGroup, caliVoteWaiter *sync.WaitGroup, caliResultWaiter *sync.WaitGroup, mainWaiter *sync.WaitGroup) {
	//./check.sh ../saveFilePlace/test.zip ../verifyFilePlace  test  MD5 (test) = 19d73de51c06285ef9bc401e7f7dc778
	defer mainWaiter.Done()
	file.CiProgress = 1
	fmt.Printf("userName:%s progress:%d\n", user.Name, file.CiProgress)
	res, err := doRunCi(user.Name, file.Name)
	if err != nil {
		res = "运行失败//00失败00"
	}

	// 投票阶段
	cryptText, oneTimeSignature, err := user.Voter.Vote(res, file.CiVoteTopic.GetRing())
	if err != nil {
		fmt.Printf("一次性环签名签名错误 %v\n", err)
		return
	}
	success, err := file.CiVoteTopic.VerifyRingSignature(oneTimeSignature)
	if err != nil || !success {
		fmt.Println("验证一次性环签名签名错误")
		return
	} else {
		file.CiResult.VoteResultDetail[string(cryptText)] = oneTimeSignature
		addComment(file, fmt.Sprintf("某位验证矿工进行了投票"), "区块链账本")
	}
	time.Sleep(time.Second * time.Duration(mathRand.Intn(10)))
	voteWaiter.Done()
	voteWaiter.Wait()
	// 计票阶段
	file.CiProgress = 2
	fmt.Printf("userName:%s progress:%d\n", user.Name, file.CiProgress)
	publishSignature, votePrivateKeyBytes, _ := user.Voter.PublishResult()
	addComment(file, fmt.Sprintf("公布一次性投票密钥 %s 用于计算结果", user.Voter.VoterSk.D.String()), user.Name)
	time.Sleep(time.Second * time.Duration(mathRand.Intn(10)))
	caliVoteWaiter.Done()
	caliVoteWaiter.Wait()
	_, voterContent, err := file.CiVoteTopic.CaliVoterSignature(&user.Voter.WalletSk.PublicKey, publishSignature, votePrivateKeyBytes, cryptText)
	if err != nil {
		fmt.Println("计票错误")
		return
	}

	file.CiProgress = 3
	addComment(file, voterContent, user.Name)
	file.CiResult.CaliResultDetail[user.Name] = voterContent
	fmt.Printf("userName:%s progress:%d\n", user.Name, file.CiProgress)
	time.Sleep(time.Second * time.Duration(mathRand.Intn(10)))
	caliResultWaiter.Done()
	caliResultWaiter.Wait()
	file.CiProgress = 4
	fmt.Printf("userName:%s progress:%d\n", user.Name, file.CiProgress)
	time.Sleep(time.Second * time.Duration(mathRand.Intn(10)))
}
func addComment(file *vote.File, comment string, userName string) {
	json := []byte("{}")
	json = util.SetJsonBytes(json, "time", time.Now().Format(time.RFC1123))
	json = util.SetJsonBytes(json, "comment", fmt.Sprintf(" <pre><code>%s</pre></code>", comment))
	json = util.SetJsonBytes(json, "user", userName)
	file.CommentList = append(file.CommentList, string(json))
}
func StartCloseVoteByUser(file *vote.File) {
	fmt.Println("开始封闭式投票流程！" + file.Name)
	file.CloseVoteTopic = &vote.Topic{
		TopicName: file.Name,
	}
	file.CloseVoteTopic.VoteStartTime = time.Now().Add(time.Second * ensureWaitSecond).Unix()
	file.CloseVoteTopic.CaliVoteStartTime = time.Now().Add(time.Second * (caliWaitSecond + ensureWaitSecond)).Unix()
	// 选择投票人
	users := randomChooseUser()
	var usersName []string
	for _, user := range users {
		usersName = append(usersName, user.Name)
	}
	addComment(file, fmt.Sprintf("使用分布式随机数信标技术产生投票用户，用户列表为 %v", usersName), "区块链账本")
	for _, user := range users {
		file.CloseVoteTopic.AddAddressList(&user.WalletSk.PublicKey)
		file.CloseVoteRandomUserNameList = append(file.CloseVoteRandomUserNameList, user.Name)
	}

	file.CloseVoteProgress = 1
	time.Sleep(time.Second * ensureWaitSecond)
	addComment(file, fmt.Sprintf("确认参与投票的用户为 %v", file.CloseVoteUserNameList), "区块链账本")
	file.CloseVoteProgress = 2
	time.Sleep(time.Second * caliWaitSecond)
	file.CloseVoteProgress = 3
	time.Sleep(time.Second * finishWaitSecond)
	file.CloseVoteProgress = 4
	scoreSum := int64(0)
	for name, content := range file.CloseCheckResult.CaliResultDetail {
		addComment(file, content, name)
		scoreSum = scoreSum + gjson.Get(content, "score").Int()
	}
	if len(file.CloseCheckResult.CaliResultDetail) != 0 {
		file.CloseCheckResult.FinalResult = scoreSum / int64(len(file.CloseCheckResult.CaliResultDetail))
		if file.CloseCheckResult.FinalResult < 0 {
			addComment(file, fmt.Sprintf("封闭式投票评分为 %d,结果不通过", file.CloseCheckResult.FinalResult), "区块链系统")
			file.CloseVoteProgress = -1
			return
		} else {
			file.CloseVoteProgress = 5
		}
	} else {
		file.CloseVoteProgress = 5
	}
	addComment(file, fmt.Sprintf("封闭式投票评分为 %d,结果为通过", file.CloseCheckResult.FinalResult), "区块链系统")
	// 开始开放式投票
	file.OpenCheckResult = &vote.VerifyResult{
		CaliResultDetail: make(map[string]string),
	}
	file.FinalResult = 1
}

func minerVerifyFiByCI(file *vote.File) {
	file.CiVoteTopic = &vote.Topic{
		TopicName: file.Name,
	}
	file.CiResult = &vote.VerifyResult{
		VoteResultDetail: make(map[string]*cryptography.RingSign),
		CaliResultDetail: make(map[string]string),
	}
	fmt.Println("开始CI验证" + file.Name)
	miners := randomChooseMiner()
	var minersName []string
	for _, miner := range miners {
		minersName = append(minersName, miner.Name)
	}
	addComment(file, fmt.Sprintf("使用分布式随机数信标技术产生验证矿工，验证矿工列表为 %v", minersName), "区块链账本")
	var index = 0
	for _, miner := range miners {
		file.CiVoteTopic.AddAddressList(&miner.WalletSk.PublicKey)
		file.CiVoteUserNameList = append(file.CiVoteUserNameList, miner.Name)
		index += 1
		generateVoter(miner, file.CiVoteTopic)
	}
	voteWaiter := &sync.WaitGroup{}
	voteWaiter.Add(len(miners))
	caliVoteWaiter := &sync.WaitGroup{}
	caliVoteWaiter.Add(len(miners))
	caliResultWaiter := &sync.WaitGroup{}
	caliResultWaiter.Add(len(miners))
	mainWaiter := &sync.WaitGroup{}
	mainWaiter.Add(len(miners))
	for _, miner := range miners {
		go verifyFile(file, miner, voteWaiter, caliVoteWaiter, caliResultWaiter, mainWaiter)
	}
	mainWaiter.Wait()
	file.CiResult.FinalResult = 5
	for _, v := range file.CiResult.CaliResultDetail {
		if strings.Contains(v, "00失败00") {
			file.CiResult.FinalResult = -5
			fmt.Println("自动化测试验证结果为失败！，终止验证流程")
			break
		}
	}
	if file.CiResult.FinalResult == 5 {
		addComment(file, "验证矿工验证结果为通过", "区块链账本")
	} else {
		addComment(file, "验证矿工验证结果为不通过", "区块链账本")
		file.CiProgress = -1
		return
	}
	file.CiProgress = 5
	fmt.Println(file.Name + "验证结束,开启封闭式投票流程")
	file.CloseCheckResult = &vote.VerifyResult{
		VoteResultDetail: make(map[string]*cryptography.RingSign),
		CaliResultDetail: make(map[string]string),
	}
	file.CloseVoteRandomUserNameList = []string{}
	go StartCloseVoteByUser(file)
}
